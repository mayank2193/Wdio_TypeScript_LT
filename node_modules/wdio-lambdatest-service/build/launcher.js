"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _perf_hooks = require("perf_hooks");

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _nodeTunnel = _interopRequireDefault(require("@lambdatest/node-tunnel"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const log = (0, _logger.default)('@wdio/lambdatest-service');

class LambdaTestLauncher {
  constructor(options) {
    this.options = options;
  }

  onPrepare(config, capabilities) {
    if (!this.options.tunnel) {
      return;
    }

    const tunnelArguments = _objectSpread({
      user: config.user,
      key: config.key
    }, this.options.lambdatestOpts);

    this.lambdatestTunnelProcess = new _nodeTunnel.default();

    if (Array.isArray(capabilities)) {
      capabilities.forEach(capability => {
        if (capability['LT:Options'] === undefined) capability.tunnel = true;else capability['LT:Options'].tunnel = true;
      });
    } else if (typeof capabilities === 'object') {
      if (capabilities['LT:Options'] === undefined) capabilities.tunnel = true;else capabilities['LT:Options'].tunnel = true;
    }

    const obs = new _perf_hooks.PerformanceObserver(list => {
      const entry = list.getEntries()[0];
      log.info(`LambdaTest Tunnel successfully started after ${entry.duration}ms`);
    });
    obs.observe({
      entryTypes: ['measure'],
      buffered: false
    });
    let timer;

    _perf_hooks.performance.mark('ltTunnelStart');

    return Promise.race([new Promise((resolve, reject) => {
      this.lambdatestTunnelProcess.start(tunnelArguments, err => {
        if (err) return reject(err);
        this.lambdatestTunnelProcess.getTunnelName(tunnelName => {
          if (Array.isArray(capabilities)) {
            capabilities.forEach(capability => {
              if (capability['LT:Options'] === undefined) capability.tunnelName = tunnelName;else capability['LT:Options'].tunnelName = tunnelName;
            });
          } else if (typeof capabilities === 'object') {
            if (capabilities['LT:Options'] === undefined) capabilities.tunnelName = tunnelName;else capabilities['LT:Options'].tunnelName = tunnelName;
          }

          resolve();
        });
      });
    }), new Promise((resolve, reject) => {
      timer = setTimeout(() => {
        reject(new Error(_constants.TUNNEL_START_FAILED));
      }, _constants.TUNNEL_STOP_TIMEOUT);
    })]).then(result => {
      clearTimeout(timer);

      _perf_hooks.performance.mark('ltTunnelEnd');

      _perf_hooks.performance.measure('bootTime', 'ltTunnelStart', 'ltTunnelEnd');

      return Promise.resolve(result);
    }, err => {
      clearTimeout(timer);
      return Promise.reject(err);
    });
  }

  onComplete() {
    if (!this.lambdatestTunnelProcess || typeof this.lambdatestTunnelProcess.isRunning !== 'function' || !this.lambdatestTunnelProcess.isRunning()) {
      return;
    }

    let timer;
    return Promise.race([new Promise((resolve, reject) => {
      this.lambdatestTunnelProcess.stop(err => {
        if (err) return reject(err);
        resolve();
      });
    }), new Promise((resolve, reject) => {
      timer = setTimeout(() => reject(new Error(_constants.TUNNEL_STOP_FAILED)), _constants.TUNNEL_STOP_TIMEOUT);
    })]).then(() => {
      clearTimeout(timer);
      return Promise.resolve();
    }, err => {
      clearTimeout(timer);
      return Promise.reject(err);
    });
  }

}

exports.default = LambdaTestLauncher;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9sYXVuY2hlci5qcyJdLCJuYW1lcyI6WyJsb2ciLCJMYW1iZGFUZXN0TGF1bmNoZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJvblByZXBhcmUiLCJjb25maWciLCJjYXBhYmlsaXRpZXMiLCJ0dW5uZWwiLCJ0dW5uZWxBcmd1bWVudHMiLCJ1c2VyIiwia2V5IiwibGFtYmRhdGVzdE9wdHMiLCJsYW1iZGF0ZXN0VHVubmVsUHJvY2VzcyIsIkxhbWJkYVRlc3RUdW5uZWxMYXVuY2hlciIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJjYXBhYmlsaXR5IiwidW5kZWZpbmVkIiwib2JzIiwiUGVyZm9ybWFuY2VPYnNlcnZlciIsImxpc3QiLCJlbnRyeSIsImdldEVudHJpZXMiLCJpbmZvIiwiZHVyYXRpb24iLCJvYnNlcnZlIiwiZW50cnlUeXBlcyIsImJ1ZmZlcmVkIiwidGltZXIiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJQcm9taXNlIiwicmFjZSIsInJlc29sdmUiLCJyZWplY3QiLCJzdGFydCIsImVyciIsImdldFR1bm5lbE5hbWUiLCJ0dW5uZWxOYW1lIiwic2V0VGltZW91dCIsIkVycm9yIiwiVFVOTkVMX1NUQVJUX0ZBSUxFRCIsIlRVTk5FTF9TVE9QX1RJTUVPVVQiLCJ0aGVuIiwicmVzdWx0IiwiY2xlYXJUaW1lb3V0IiwibWVhc3VyZSIsIm9uQ29tcGxldGUiLCJpc1J1bm5pbmciLCJzdG9wIiwiVFVOTkVMX1NUT1BfRkFJTEVEIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7OztBQUNBLE1BQU1BLEdBQUcsR0FBRyxxQkFBTywwQkFBUCxDQUFaOztBQUNlLE1BQU1DLGtCQUFOLENBQXlCO0FBQ3BDQyxFQUFBQSxXQUFXLENBQUNDLE9BQUQsRUFBVTtBQUNqQixTQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDSDs7QUFHREMsRUFBQUEsU0FBUyxDQUFDQyxNQUFELEVBQVNDLFlB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RSxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFFN0JOLE1BQUFBLEtBQUssR0FBR1csVUFBVSxDQUFDLE1BQU1MLE1BQU0sQ0FBRSxJQUFJTSxLQUFKLENBQVVVLDZCQUFWLENBQUYsQ0FBYixFQUErQ1IsOEJBQS9DLENBQWxCO0FBQ0gsS0FIRCxDQVBnQixDQUFiLEVBV0pDLElBWEksQ0FZSCxNQUFNO0FBQ0ZFLE1BQUFBLFlBQVksQ0FBQ2pCLEtBQUQsQ0FBWjtBQUNBLGFBQU9HLE9BQU8sQ0FBQ0UsT0FBUixFQUFQO0FBQ0gsS0FmRSxFQWlCRkcsR0FBRCxJQUFTO0FBQ0xTLE1BQUFBLFlBQVksQ0FBQ2pCLEtBQUQsQ0FBWjtBQUNBLGFBQU9HLE9BQU8sQ0FBQ0csTUFBUixDQUFlRSxHQUFmLENBQVA7QUFDSCxLQXBCRSxDQUFQO0FBc0JIOztBQXJIbUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwZXJmb3JtYW5jZSwgUGVyZm9ybWFuY2VPYnNlcnZlciB9IGZyb20gJ3BlcmZfaG9va3MnXG5pbXBvcnQgbG9nZ2VyIGZyb20gJ0B3ZGlvL2xvZ2dlcidcbmltcG9ydCBMYW1iZGFUZXN0VHVubmVsTGF1bmNoZXIgZnJvbSAnQGxhbWJkYXRlc3Qvbm9kZS10dW5uZWwnXG5pbXBvcnQgeyBUVU5ORUxfU1RBUlRfRkFJTEVELCBUVU5ORUxfU1RPUF9GQUlMRUQsIFRVTk5FTF9TVE9QX1RJTUVPVVQgfSBmcm9tICcuL2NvbnN0YW50cydcbmNvbnN0IGxvZyA9IGxvZ2dlcignQHdkaW8vbGFtYmRhdGVzdC1zZXJ2aWNlJylcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhbWJkYVRlc3RMYXVuY2hlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgfVxuXG4gICAgLy8gbW9kaWZ5IGNvbmZpZyBhbmQgbGF1bmNoIHR1bm5lbFxuICAgIG9uUHJlcGFyZShjb25maWcsIGNhcGFiaWxpdGllcykge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy50dW5uZWwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHVubmVsQXJndW1lbnRzID0ge1xuICAgICAgICAgICAgdXNlcjogY29uZmlnLnVzZXIsXG4gICAgICAgICAgICBrZXk6IGNvbmZpZy5rZXksXG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMubGFtYmRhdGVzdE9wdHNcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFtYmRhdGVzdFR1bm5lbFByb2Nlc3MgPSBuZXcgTGFtYmRhVGVzdFR1bm5lbExhdW5jaGVyKClcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjYXBhYmlsaXRpZXMpKSB7XG4gICAgICAgICAgICBjYXBhYmlsaXRpZXMuZm9yRWFjaChjYXBhYmlsaXR5ID0+IHtcbiAgICAgICAgICAgICAgICBpZihjYXBhYmlsaXR5WydMVDpPcHRpb25zJ109PT11bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdHkudHVubmVsID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0eVsnTFQ6T3B0aW9ucyddLnR1bm5lbCA9IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNhcGFiaWxpdGllcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmKGNhcGFiaWxpdGllc1snTFQ6T3B0aW9ucyddPT09dW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllcy50dW5uZWwgPSB0cnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzWydMVDpPcHRpb25zJ10udHVubmVsID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIC8vIG1lYXN1cmUgTFQgYm9vdCB0aW1lXG4gICAgICAgIGNvbnN0IG9icyA9IG5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKGxpc3QgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBsaXN0LmdldEVudHJpZXMoKVswXVxuICAgICAgICAgICAgbG9nLmluZm8oXG4gICAgICAgICAgICAgICAgYExhbWJkYVRlc3QgVHVubmVsIHN1Y2Nlc3NmdWxseSBzdGFydGVkIGFmdGVyICR7ZW50cnkuZHVyYXRpb259bXNgXG4gICAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICAgIG9icy5vYnNlcnZlKHsgZW50cnlUeXBlczogWydtZWFzdXJlJ10sIGJ1ZmZlcmVkOiBmYWxzZSB9KVxuXG4gICAgICAgIGxldCB0aW1lclxuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKCdsdFR1bm5lbFN0YXJ0JylcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYW1iZGF0ZXN0VHVubmVsUHJvY2Vzcy5zdGFydCh0dW5uZWxBcmd1bWVudHMsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhbWJkYXRlc3RUdW5uZWxQcm9jZXNzLmdldFR1bm5lbE5hbWUodHVubmVsTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjYXBhYmlsaXRpZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzLmZvckVhY2goY2FwYWJpbGl0eSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhcGFiaWxpdHlbJ0xUOk9wdGlvbnMnXT09PXVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdHkudHVubmVsTmFtZSA9IHR1bm5lbE5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0eVsnTFQ6T3B0aW9ucyddLnR1bm5lbE5hbWUgPSB0dW5uZWxOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNhcGFiaWxpdGllcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYXBhYmlsaXRpZXNbJ0xUOk9wdGlvbnMnXT09PXVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzLnR1bm5lbE5hbWUgPSB0dW5uZWxOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXNbJ0xUOk9wdGlvbnMnXS50dW5uZWxOYW1lID0gdHVubmVsTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsgcmVqZWN0KCBuZXcgRXJyb3IoVFVOTkVMX1NUQVJUX0ZBSUxFRCkpIH0sIFRVTk5FTF9TVE9QX1RJTUVPVVQpXG4gICAgICAgICAgICB9KVxuICAgICAgICBdKS50aGVuKFxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpXG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnbHRUdW5uZWxFbmQnKVxuICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ2Jvb3RUaW1lJywgJ2x0VHVubmVsU3RhcnQnLCAnbHRUdW5uZWxFbmQnKVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycilcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgIH1cblxuICAgIG9uQ29tcGxldGUoKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICF0aGlzLmxhbWJkYXRlc3RUdW5uZWxQcm9jZXNzIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5sYW1iZGF0ZXN0VHVubmVsUHJvY2Vzcy5pc1J1bm5pbmcgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICF0aGlzLmxhbWJkYXRlc3RUdW5uZWxQcm9jZXNzLmlzUnVubmluZygpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdGltZXJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYW1iZGF0ZXN0VHVubmVsUHJvY2Vzcy5zdG9wKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KCBuZXcgRXJyb3IoVFVOTkVMX1NUT1BfRkFJTEVEKSksIFRVTk5FTF9TVE9QX1RJTUVPVVQpXG4gICAgICAgICAgICB9KVxuICAgICAgICBdKS50aGVuKFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcilcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcilcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgICAgICAgICAgfVxuICAgICAgICApXG4gICAgfVxufSJdfQ==